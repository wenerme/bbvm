package bbvm

import (
	"bytes"
	"github.com/op/go-logging"
	"testing"
)

func TestASM1(t *testing.T) {
	/*
	CALL LABEL0 ; For initialization
	LD dword r2,CD_INITDATA
	IN r2,22
	PUSH [CSTRING_3]
	POP r2
	IN r3,2
	IN r2,5
	PUSH r3
	POP r3
	OUT 2,r3
	IN r3,8
	OUT 4,10
	EXIT
	LABEL0:
	LD dword [CSTRING_3],CS_CSTRING_3
	RET
	LABEL1:
	EXIT
	LABEL2:
	DATA CSTRING_3 dword 0
	DATA CS_CSTRING_3 char \"ABC\",0
	DATA CD_INITDATA bin

	00000000  42 42 45 00 00 00 00 40  00 00 00 00 00 00 00 00  |BBE....@........|
	00000010  82 60 00 00 00 10 02 06  00 00 00 77 00 00 00 40  |.`.........w...@|
	00000020  02 06 00 00 00 16 00 00  00 23 6c 00 00 00 30 06  |.........#l...0.|
	00000030  00 00 00 40 02 07 00 00  00 02 00 00 00 40 02 06  |...@.........@..|
	00000040  00 00 00 05 00 00 00 20  07 00 00 00 30 07 00 00  |....... ....0...|
	00000050  00 50 08 02 00 00 00 07  00 00 00 40 02 07 00 00  |.P.........@....|
	00000060  00 08 00 00 00 50 0a 04  00 00 00 0a 00 00 00 f0  |.....P..........|
	00000070  10 0e 6c 00 00 00 70 00  00 00 90 f0 00 00 00 00  |..l...p.........|
	00000080  41 42 43 00 00 00 00                              |ABC....
	*/

	data := []byte{
		0x82, 0x60, 0x00, 0x00, 0x00, 0x10, 0x02, 0x06, 0x00, 0x00, 0x00, 0x77, 0x00, 0x00, 0x00, 0x40,
		0x02, 0x06, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x23, 0x6c, 0x00, 0x00, 0x00, 0x30, 0x06,
		0x00, 0x00, 0x00, 0x40, 0x02, 0x07, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x40, 0x02, 0x06,
		0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x20, 0x07, 0x00, 0x00, 0x00, 0x30, 0x07, 0x00, 0x00,
		0x00, 0x50, 0x08, 0x02, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x40, 0x02, 0x07, 0x00, 0x00,
		0x00, 0x08, 0x00, 0x00, 0x00, 0x50, 0x0a, 0x04, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0xf0,
		0x10, 0x0e, 0x6c, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x90, 0xf0, 0x00, 0x00, 0x00, 0x00,
		0x41, 0x42, 0x43, 0x00, 0x00, 0x00, 0x00,
	}
	r := []byte{}
	r = append(r, data...)
	op := Inst{}
	w := []byte{}
	for {
		op.UnmarshalBinary(r)
		b, _ := op.MarshalBinary()
		w = append(w, b...)
		r = r[op.Opcode.Len():]
		//		log.Println(op)
		if op.Opcode == OP_EXIT {
			break
		}
	}
	//	t.Log("\n", hex.Dump(w))
	if bytes.Compare(w, data[0:len(w)]) != 0 {
		t.Error("MarshalBinary Not match")
	}
}
func TestVM(t *testing.T) {
	logging.SetLevel(logging.INFO, "bbvm")

	data := []byte{
		0x82, 0x60, 0x00, 0x00, 0x00, 0x10, 0x02, 0x06, 0x00, 0x00, 0x00, 0x77, 0x00, 0x00, 0x00, 0x40,
		0x02, 0x06, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x23, 0x6c, 0x00, 0x00, 0x00, 0x30, 0x06,
		0x00, 0x00, 0x00, 0x40, 0x02, 0x07, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x40, 0x02, 0x06,
		0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x20, 0x07, 0x00, 0x00, 0x00, 0x30, 0x07, 0x00, 0x00,
		0x00, 0x50, 0x08, 0x02, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x40, 0x02, 0x07, 0x00, 0x00,
		0x00, 0x08, 0x00, 0x00, 0x00, 0x50, 0x0a, 0x04, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0xf0,
		0x10, 0x0e, 0x6c, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x90, 0xf0, 0x00, 0x00, 0x00, 0x00,
		0x41, 0x42, 0x43, 0x00, 0x00, 0x00, 0x00,
	}
	v := NewVM()

	v.Load(data)
	out := &bytes.Buffer{}
	OUT.OutputToWriter(v, out)
	IN.All(v)
	for !v.IsExited() {
		v.Loop() // call
		//		log.Info(v.Report())
	}
	//	log.Info(v.Report())
	//	log.Info(v.GetStr(112))

	if out.String() != "ABC\n" {
		t.Error("Output not match, got %s", out.String())
	}
}
